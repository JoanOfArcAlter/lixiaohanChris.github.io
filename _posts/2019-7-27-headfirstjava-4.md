---
layout: post
title:  "headfirstjava第四章笔记"
date:   2019-07-27 18:12:00 +0800
categories: Java
tags: Java HeadFirstJava
author: lxh
mathjax: true
---

* content
{:toc}
head first Java第四章



## 状态影响行为，行为影响状态

###### 类所描述的是对象知道什么与执行什么

> 任一类的每个实例都带有相同的方法，但是方法方法可以根据实例变量的值来表现不同的行为

###### 方法会运用形参。调用的一方会传入实参

> 实参是传给方法的值。当它传入方法后就成了形参

###### Java是通过值传递的，也就是说通过拷贝传递

```
int x = 7;
void go(int z){
    z = 0;
}
foo.go(x);//x的值不会因z而改变,x与z并无连接关系
```

## 封装

###### 基本原则

> 将你的实例变量标记为私有的（`pribate`），并提供公有的（`public`）`getter`与`setter`来控制存取动作。

###### 封装是如何设下保护罩的？

> 强迫其他的程序一定得经过`setter`。如此`setter`就能够检查参数并判断是否可以执行。`setter`也许可以退回不合理的值、或是抛出`Exception`、或者自己进行取小数点的动作。重点在于你可于`setter`中执行任何动作，直接暴露的pulbic实体变量就没这个能耐。

> 这对`getter`也是一样的，好处是你事后可以改变想法却不会需要改变其他部分的程序。假设说所有人都是用到你的类以及公有变量，万一有一天你发现这个变量需要检查，那不是所有人都要跟着改成调用`setter`吗？封装的优点就是能够让你三心二意却又不会伤害别人。直接存取的效率是比不上这个好处的。

##### 虽然有的`getter`、`setter`方法没有加上实质的功能性，但重要的是允许你能够在事后改变心意；你可以回头把程序改得更安全、更快、更好。

## 声明与初始化实例变量

###### 实例变量永远都会有默认值.如果你没有明确的赋值给实例变量,或者没有调用setter,实例变量还是会有值!

- integers:0
- floating points:0.0
- booleans:false
- references:null

###### `char`的默认值是`'\u0000'`,转化成`int`也是0。`Character`是`char`的包装类，默认值是`null`

[关于char的默认值](https://wenwen.sogou.com/z/q801117805.htm)

#### 实例变量与局部变量之间的差别

1. 实例变量是声明在类内而不是方法中
2. 局部变量是声明在方法中的
3. 局部变量在使用前必须初始化

```
class Foo{
    public void go(){
        int x;
        int z = x + 3;//无法编译！你可以声明没有值的x，但若要使用时编译器就会给出警示
    }
}
```

##### 局部变量没有默认值！如果在变量被初始前就要使用的话，编译器会显示错误。

###### 那方法的参数呢？局部变量的规则也适用于它们身上吗？

> 方法的参数基本上与局部变量是相同的————它们都是在方法中声明的（精确的说应该是在方法的参数列表生命的，但相较于实例变量来说它也算是局部的）。而参数并没有未声明的问题，所以编译器也不可能对这样的事情显示出错误。

> 这是因为如果调用方法而没有赋值参数时编译器就会显示错误。所以说参数一定会被初始化，编译器会确保方法被调用时会有与声明所相符的参数，且参数会自动地被赋值进去。

## 变量的比较

##### 使用==来比对primitive主数据类型

##### 使用==来判别两个引用是否都指向同一对象

> 这个运算式可以用来比较任何类型的两个变量，它只是比较其中的字节组合。引用变量可以判断是否是参照的相同对象。

##### 使用equals()来判断两个对象是否在意义上相等（像是两个String对象是否带有相同的字节组合）

###### Java是值传递的（也就是拷贝传递）

**李晓晗**

**更新于2019-7-27 下午**
